---
title: "Microglia clustering"
author: "Luise A. Seeker/Sunniva Bostrand"
date: "13/08/20201"
html_document:
toc: true
toc_depth: 4
theme: united
---

# Introduction

The purpose of this script is to find variable genes, cluster the microglia
dataset at different resolutions, find some rough markers for cluster
stability/ purity that may help to decide which clusters to use, and find 
marker genes for those clusters. 

# Load libraries

```{r, echo = F}
library(dplyr)
library(viridis) 
library(ggsci)
library(scales)
library(SingleCellExperiment)
library(EnhancedVolcano)
library(NMF)
library(pheatmap)
library(dendextend)
library(limma)
library(StatMeasures)
library(ggplot2)
library(ggdendro)
library(zoo)
library(clustree)
library(philentropy)
library(bluster)
#library(scclusteval)
library(gtools)
library(tidyr)

```


# Pick colour palettes

```{r, echo = F}
mypal <- pal_npg("nrc", alpha = 0.7)(10)
mypal2 <-pal_tron("legacy", alpha = 0.7)(7)
mypal3 <- pal_lancet("lanonc", alpha = 0.7)(9)
mypal4 <- pal_simpsons(palette = c("springfield"), alpha = 0.7)(16)
mypal5 <- pal_rickandmorty(palette = c("schwifty"), alpha = 0.7)(6)
mypal6 <- pal_futurama(palette = c("planetexpress"), alpha = 0.7)(5)
mypal7 <- pal_startrek(palette = c("uniform"), alpha = 0.7)(5)

mycoloursP<- c(mypal, mypal2, mypal3, mypal4, mypal5, mypal6, mypal7)

```


# Read in dataset

```{r, echo = F}
seur_comb <- readRDS("/exports/eddie/scratch/s1359339/HD/20211005_swapped_data/20211005_seur_comb_qc_integrated_annot_swappedsamples.rds")
mglia <-subset(seur_comb, idents = c("MiMa1", "MiMa2"))

```

#Check QC

```{r}

Idents(mglia) <- "Tissue"
VlnPlot(mglia, features = c("nFeature_RNA", 
                             "nCount_RNA", 
                             "percent.mt"))

VlnPlot(mglia, features = c("nFeature_RNA", 
                             "nCount_RNA", 
                             "percent.mt"), 
        pt.size = 0, 
        cols = mycoloursP)

```

```{r}
plot1 <- FeatureScatter(mglia, 
                        feature1 = "nCount_RNA", 
                        feature2 = "percent.mt", 
                        cols = mycoloursP)

plot2 <- FeatureScatter(mglia, 
                        feature1 = "nCount_RNA", 
                        feature2 = "nFeature_RNA", 
                        cols = mycoloursP)
plot1 + plot2


```

# Find variable features
```{r}

DefaultAssay(mglia) <-"integrated"

#mglia <- FindVariableFeatures(mglia, 
#                               selection.method = "vst", 
#                               nfeatures = 2000)

# Identify the 10 most highly variable genes
#top10 <- head(VariableFeatures(mglia), 10)

# plot variable features with and without labels
#plot1 <- VariableFeaturePlot(mglia)
#plot2 <- LabelPoints(plot = plot1, 
#                     points = top10, 
#                     repel = TRUE)
#plot1 + plot2



```

# Scale data

```{r}
all_genes <- rownames(mglia)
mglia <- ScaleData(mglia, features= all_genes)

```

# Linear dimensional reduction

```{r}
mglia <- RunPCA(mglia, features = VariableFeatures(object = mglia))
ElbowPlot(mglia)

```

```{r}
#mglia@graphs$integrated_snn <- "integrated_snn"

mglia <- FindNeighbors(mglia, dims = 1:14)

# test different resolutions for clustering
mglia <- FindClusters(mglia, resolution = c(0.01, 0.04, 0.06, 0.08,
                                              seq(from = 0.1, to = 1, by = 0.1)), graph.name = "integrated_snn")


# non-linear reduction
mglia <- RunUMAP(mglia, dims = 1:14)


#Generate DimPlot of all tested clustering resolutions in metadata
# requires gtools library and Seurat
plot_list_func <- function(seur_obj,
                           col_pattern, 
                           plot_cols, 
                           clust_lab = TRUE,
                           label_size = 8,
                           num_col = 4,
                           save_dir = getwd(),
                           width=7,
                           height=5){
  extr_res_col <- grep(pattern = col_pattern, names(seur_obj@meta.data))
  res_names <- names(seur_obj@meta.data[extr_res_col])
  # gtools function, sorts gene_names alphanumeric:
  res_names <- mixedsort(res_names) 
  plot_l <-list()
  for(i in 1: length(res_names)){
  pdf(paste0(save_dir, 
               res_names[i], "_umap.pdf"), width=width, height=height)
  dim_plot <- DimPlot(seur_obj, 
                          reduction = "umap", 
                          cols= plot_cols,
                          group.by = res_names[i],
                          label = clust_lab,
                          label.size = label_size) + NoLegend()
  print(dim_plot)
  dev.off()
  print(dim_plot)
  }
}

dir.create("/exports/eddie/scratch/s1359339/HD/20211005_swapped_data/mglia_out")

dir.create("/exports/eddie/scratch/s1359339/HD/20211005_swapped_data/mglia_out/diff_dim_pl")
plot_list_func(seur_obj = mglia, 
                          col_pattern = "integrated_snn_res.",
                          plot_cols = mycoloursP[6:40],
                          save_dir = "/exports/eddie/scratch/s1359339/HD/20211005_swapped_data/mglia_out/diff_dim_pl/" )


```



```{r, fig.width = 8, fig.height = 1.5}

DimPlot(mglia, group.by = "Tissue", split.by = "Tissue")

```


# Marker genes for migroglia and macrophages

```{r, fig.width = 8, fig.height = 1.5}
dir.create("/exports/eddie/scratch/s1359339/HD/20211005_swapped_data/mglia_out/feat_pl")

pdf("/exports/eddie/scratch/s1359339/HD/20211005_swapped_data/mglia_out/feat_pl/olig_OPCs.pdf", 
   paper = "a4", width=13, height=20)
DefaultAssay(mglia) <- "integrated"
print(FeaturePlot(mglia, features = c("CD74", 
                                     "SPI1", 
                                     "MRC1", 
                                     "TMEM119", 
                                     "CX3CR1",
                                     "P2RY13",
                                     "CD68",
                                     "TREM2",
                                     "IGF1",
                                     "SPP1",
                                     "ITGAX",
                                     "AIF1",
                                     "P2RY12",
                                     "C1QC",
                                     "C1QA"), ncol = 4))

dev.off()

```






```{r}

dir.create("/exports/eddie/scratch/s1359339/HD/20211005_swapped_data/mglia_out/clust_tree")

pdf("/exports/eddie/scratch/s1359339/HD/20211005_swapped_data/mglia_out/clust_tree/clust_tree.pdf", 
    paper="a4", width=8, height=11.5)
clustree(
  mglia,
  prefix = paste0("integrated", "_snn_res."),
  exprs = c("data", "counts", "scale.data"),
  assay = NULL
)

dev.off()

```

```{r}
#mglia_sce <- as.SingleCellExperiment(mglia, assay = "integrated")
mglia_sce <- readRDS("/exports/eddie/scratch/s1359339/HD/20211005_swapped_data/mglia_out/20211027_Mglia_SCE.rds")
```





```{r}
sil_plot <- function(sce_obj, reduction = "PCA",
                           col_pattern = "integrated_snn_res", 
                           plot_cols, 
                           clust_lab = TRUE,
                           label_size = 8,
                           num_col = 4,
                           save_dir = getwd(),
                           width=7,
                           height=5){
  res_col <- grep(pattern = col_pattern, names(colData(sce_obj)))
  names_col <- names(colData(sce_obj))[res_col]
  # gtools function, sorts gene_names alphanumeric:
  names_col <- mixedsort(names_col)
  met_dat <- as.data.frame(colData(mglia_sce))
  distance <- dist(reducedDim(sce_obj, reduction))

  for(i in 1: length(names_col)){
  clust <- met_dat[[names_col[i]]]
  clust_int <- as.integer(paste0(clust))
  sil <- silhouette(clust_int, dist = distance)
  
  pdf(paste0(save_dir, 
               names_col[i], "_sil.pdf"), width=width, height=height)
  plot(sil, border = NA)
  dev.off()
  plot(sil, border = NA)
  if(i == 1){
    av_sil_df <- data.frame(res = names_col[i], 
                            av_sil_w = summary(sil)$avg.width)
  }else{
     append_df <- data.frame(res = names_col[i], 
                            av_sil_w = summary(sil)$avg.width)
     av_sil_df <- rbind(av_sil_df, append_df)
  }
  }
  return(av_sil_df)
}

dir.create("/exports/eddie/scratch/s1359339/HD/20211005_swapped_data/mglia_out/sil_pl")

av_df <- sil_plot(sce_obj = mglia_sce, 
                          col_pattern = "integrated_snn_res.",
                          plot_cols = mycoloursP[6:40],
                          save_dir = "/exports/eddie/scratch/s1359339/HD/20211005_swapped_data/mglia_out/sil_pl/" )


av_df$num_res <- as.numeric(sapply(strsplit(av_df$res,"res."), `[`, 2))

av_sil_pl <-ggplot(av_df, aes(x = num_res, y = av_sil_w)) + 
                    geom_line(color="grey") + 
                    geom_point(shape=21, color="black", fill="#69b3a2", size=6) + 
                    theme_bw() +
                    ylab("Average silhouette width") +
                    scale_x_continuous(name = "Cluster resolution", 
                        breaks = av_df$num_res) +
                   theme(axis.text.x = element_text(angle = 90))



pdf("/exports/eddie/scratch/s1359339/HD/20211005_swapped_data/mglia_out/sil_pl/av_sil_pl.pdf", 
     width=8, height=4)
print(av_sil_pl)
dev.off()

```

Approximate silhouette

```{r}

approx_sil <- function(sce_obj, reduction = "PCA",
                           col_pattern = "integrated_snn_res", 
                           plot_cols, 
                           clust_lab = TRUE,
                           label_size = 8,
                           save_dir = getwd(),
                           width=7,
                           height=5){
  res_col <- grep(pattern = col_pattern, names(colData(sce_obj)))
  names_col <- names(colData(sce_obj))[res_col]
  # gtools function, sorts gene_names alphanumeric:
  names_col <- mixedsort(names_col)
  met_dat <- as.data.frame(colData(mglia_sce))

  for(i in 1: length(names_col)){
    clust <- met_dat[[names_col[i]]]
    clust_int <- as.integer(paste0(clust))
    
    sil_approx <- approxSilhouette(reducedDim(sce_obj, reduction), 
                                   clusters = clust_int)
    sil_data <- as.data.frame(sil_approx)
    sil_data$closest <- factor(ifelse(sil_data$width > 0, clust_int, sil_data$other))
    sil_data$cluster <- factor(clust_int)
    
    apr_sil_plot <-ggplot(sil_data, aes(x=cluster, y=width, colour=closest)) + 
    ggbeeswarm::geom_quasirandom(method="smiley") + theme_bw(20) +
      xlab(names_col[i])
    
    
  pdf(paste0(save_dir, 
               names_col[i], "_sil.pdf"), width=width, height=height)
  
 
  print(apr_sil_plot)
  
  dev.off()
  
  print(apr_sil_plot)
  }
  print("Done")
}

dir.create("/exports/eddie/scratch/s1359339/HD/20211005_swapped_data/mglia_out/appr_sil")


approx_sil(sce_obj = mglia_sce, 
                          col_pattern = "integrated_snn_res.",
                          plot_cols = mycoloursP[6:40],
                          save_dir = "/exports/eddie/scratch/s1359339/HD/20211005_swapped_data/mglia_out/appr_sil/" )
  

```


Cluster purity

```{r}


clu_pure <- function(sce_obj, reduction = "PCA",
                           col_pattern = "integrated_snn_res", 
                           plot_cols, 
                           clust_lab = TRUE,
                           label_size = 8,
                           save_dir = getwd(),
                           width=7,
                           height=5){
  res_col <- grep(pattern = col_pattern, names(colData(sce_obj)))
  names_col <- names(colData(sce_obj))[res_col]
  # gtools function, sorts gene_names alphanumeric:
  names_col <- mixedsort(names_col)
  met_dat <- as.data.frame(colData(mglia_sce))

  for(i in 1: length(names_col)){
    clust <- met_dat[[names_col[i]]]
    clust_int <- as.integer(paste0(clust))
    
    pure <- neighborPurity(reducedDim(sce_obj, reduction), clusters = clust_int)
    pure_data <- as.data.frame(pure)
    pure_data$maximum <- factor(pure_data$maximum)
    pure_data$cluster <- factor(clust_int)
    
    
    pure_plot <- ggplot(pure_data, aes(x=cluster, y=purity, colour=maximum)) + 
      ggbeeswarm::geom_quasirandom(method="smiley") +
      theme_bw(20) +
      xlab(names_col[i])
    
    
    pdf(paste0(save_dir, 
               names_col[i], "_sil.pdf"), width=width, height=height)
    
    print(pure_plot)
  
    dev.off()
    
    print(pure_plot)
  }
  print("Done")
}

dir.create("/exports/eddie/scratch/s1359339/HD/20211005_swapped_data/mglia_out/clust_pure")


clu_pure(sce_obj = mglia_sce, 
                          col_pattern = "integrated_snn_res.",
                          plot_cols = mycoloursP[6:40],
                          save_dir = "/exports/eddie/scratch/s1359339/HD/20211005_swapped_data/mglia_out/clust_pure/")




```


 think the only way to 
select the maximum number of clusters is to
  1) test for discriminating differentially expressed genes
  2) validate those gene markers (or their proteins) in tissue

# Annotation

After having had a look further downstream, I decided about a resolution to use
for which I am confident to find markers for each cluster. Therefore I am now
going to give clusters at that chosen resolutions names

```{r}
Idents(mglia) <- "integrated_snn_res.0.2"
  mglia <-  RenameIdents(
    mglia,
    "0" = "MM_Rose",
    "1" = "MM_Violet",
    "2" = "MM_Lily",
    "3" = "MM_Daisy",
    "4" = "MM_Tulip",
    "5" = "MM_Orchid", #BAMs
    "6" = "MM_Lupin",
    "7" = "MM_Pansy"
    )
# Plot result
DimPlot(mglia,label = TRUE, repel=TRUE)
dim_pl <- DimPlot(mglia,label = TRUE, repel=FALSE, cols = mycoloursP[6:40],
                  label.size = 4.5)
dim_pl
# Save result
mglia$mm_clusters_named <- Idents(mglia)


pdf("/exports/eddie/scratch/s1359339/HD/20211005_swapped_data/mglia_out/diff_dim_pl/annotated_0_1.pdf", 
     width=8, height=5)
print(dim_pl)

dev.off()


```

# Cluster QC

#### Individuals per cluster
How many individuals contribute to each cluster?

```{r indiv-per-cluster}
mglia@meta.data$mm_clusters_named <- factor(mglia@meta.data$mm_clusters_named,
                                             levels = c("MM_Rose","MM_Violet","MM_Lily","MM_Daisy","MM_Tulip", "MM_Orchid", "MM_Lupin", "MM_Pansy"))

# count how many cells there are in each group and cluster
sum_donor_id_cluster <- table(mglia$mm_clusters_named, mglia$donor_id)
# For each cluster (on the rows) sum of individuals that do have cells on that cluster
rowSums(sum_donor_id_cluster > 0)
```
#### Percentage of cells that come from each individual

Some of the clusters might be mainly from one person, even though other subjects
do have some cells that cluster with it. To address this question we calculate
for each cluster the proportion of cells that come from each donor_id.

```{r prop-per-cluster}

# calculate the proportions, for each cluster (margin 1 for rows)
prop_donor_id_table <- prop.table(sum_donor_id_cluster, margin = 1)
# change the format to be a data.frame, this also expands to long formatting
prop_donor_id <- as.data.frame(prop_donor_id_table)
colnames(prop_donor_id) <- c("cluster", "donor_id", "proportion")
```

Flag the clusters where one of the individuals covers more than 40% of the
cluster. The expected would be around `1/12= 8%`

```{r}
prop_donor_id[prop_donor_id$proportion > 0.4, ]
```


#### Minimum threshold of 5% contribution to count individuals
Another interesting variable is the number of individuals that contribute to
more than a certain threshold (5%) to each cluster

```{r min-pct}
# Calculuate for each cluster the number of individuals that fulfill the condition of contributing more than a 15%
num_individuals_gt_5pt <- rowSums(prop_donor_id_table > 0.05)
# Sort the clusters by ascending order of number of individuals that contribute more than 2%
sort(num_individuals_gt_5pt)
#And a general overview of the data
summary(num_individuals_gt_5pt)
# Save the ones that are formed by less than 5 individuals that fulfill the condition
(clusters_bad <- rownames(prop_donor_id_table)[which(num_individuals_gt_5pt < 5)])

```



Plot the proportions for donor_id

```{r prop-plot}
# plot a barplot


ggplot(data = prop_donor_id, aes(x = cluster, y = proportion, fill = donor_id)) +
  geom_bar(stat = "identity") + theme_classic() + scale_fill_manual(values=mycoloursP[1:20])
```

It is also worth keeping in mind the size of the cluster, there are in ascending
order (0 is the biggest cluster and 10 the smallest).

#### Samples instead of individuals

The proportions are again calculated but taking into consideration the samples 
instead of the individuals

```{r}
# count how many cells there are in each group and cluster
sum_donor_idtissue_cluster <- table(mglia$mm_clusters_named, mglia$ProcessNumber)
# calculate the proportions, for each cluster (margin 1 for rows)
prop_donor_idtissue_table <- prop.table(sum_donor_idtissue_cluster, margin = 1)
# change the format to be a data.frame, this also expands to long formatting
prop_donor_idtissue <- as.data.frame(prop_donor_idtissue_table)
colnames(prop_donor_idtissue) <- c("cluster", "ProcessNumber", "proportion")
prop_donor_idtissue[prop_donor_idtissue$proportion > 0.3, ]
```





# Compositional differences with age, sex and regions 

Some general distributions about the data. We started with equal number of
sex/age/tissues but because we deleted samples these are not equal any more.
Also the number of cells from each one might differ

```{r general}
# Number of samples per tissue
colSums(table(mglia$ProcessNumber, mglia$Tissue)>0)


#number of nuclei per tissue
table(mglia$Tissue)


```


## Age and Sex Grouping

Separate by both things in 4 plots. The plots are corrected by number of cells
per sexage group first (looking at the distribution of each group across
clusters) and then corrected for the number of cells per cluster (to visualize
the small and big clusters equally).

```{r, fig.width=15, fig.height=10}
# Sex
# DimPlot(mglia, split.by = "ageSex", group.by = "Tissue", ncol = 5)
DimPlot(mglia, split.by = "Tissue", group.by = "mm_clusters_named", ncol = 2,
        cols = mycoloursP, pt.size = 2, label = TRUE, label.size = 6)
```



## Tissue

split the clustering by the original tissues

```{r, fig.width=8, fig.height=8}
Idents(mglia) <- mglia$mm_clusters_named
umap_clusters <- DimPlot(mglia, split.by = "Tissue", ncol = 2, 
                         cols = mycoloursP, pt.size = 2, label = T) +NoLegend()
umap_clusters
```

Calculate proportion clusters for each Tissue

```{r}
# count how many cells there are in each group and cluster
sum_tissue_cluster <- table(mglia$mm_clusters_named, mglia$Tissue)
# Delete the row that does not contain any cell (cluster 26,that has been removed)
keep <- rowSums(sum_tissue_cluster) > 0
sum_tissue_cluster <- sum_tissue_cluster[keep,]

# Calculate the proportions for each group: 
# allows to normalise the groups and give the same weight to all groups, 
# even though they might have different cell numbers (margin 2 for cols)
prop_tissue_table_2 <- prop.table(sum_tissue_cluster, margin = 2)
# calculate the proportions, for each cluster, 
# allows to visualize on a scale from 0 to 1 (margin 1 for rows)
prop_tissue_table_2_1 <- prop.table(prop_tissue_table_2, margin = 1)
# change the format to be a data.frame, this also expands to long formatting
prop_tissue <- as.data.frame(prop_tissue_table_2)
colnames(prop_tissue) <- c("cluster", "Tissue", "proportion")


#plot
ggplot(data = prop_tissue, aes(x = cluster, y = proportion, fill = Tissue)) +
  geom_bar(stat = "identity") + theme_classic() + 
  scale_fill_manual(values=mycoloursP[24:40]) +
  ylab("Normalised counts")


ggplot(data = prop_tissue, aes(x = cluster, y = proportion, fill = Tissue)) +
  geom_bar(position = "fill", stat = "identity") + theme_classic() + 
  scale_fill_manual(values=mycoloursP[24:40]) 
```



```{r}

saveRDS(mglia, "/exports/eddie/scratch/s1359339/HD/20211005_swapped_data/mglia_out/20211027_Mglia.rds")

```


```{r}
sessionInfo()
```
